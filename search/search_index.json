{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Json Model A Collection of Methods for Validating JSON Structured Data by Collective Acuity Downloads http://pypi.python.org/pypi/jsonModel Source https://github.com/collectiveacuity/jsonModel Documentation https://collectiveacuity.github.io/jsonModel/ Introduction Json Model is designed to facilitate the process of implementing data validation against a declared json data model. The jsonModel class offers a more intuitive declaration process than other schema enforcement modules currently available by relying upon the architecture of json itself to validate datatypes, requirements and defaults. Installation From PyPi:: $ pip install jsonmodel From GitHub:: $ git clone https://github.com/collectiveacuity/jsonmodel $ cd jsonmodel $ python setup.py install Getting Started This module uses self-valid schema declarations as a method to describe data requirements. As a result, for many data models, full validation can be achieved from an example declaration using the schema key:: { \"schema\": { \"userID\": \"gY3Cv81QwL0Fs\", \"datetime\": 1456000345.543713, \"active\": true, \"address\": { \"city\": \"New Orleans\", \"region\": \"LA\", \"postal_code\": \"\", \"country\": \"United States\" } } } [In this model, the input must contain values for all four top level keys and each value must correspond to the datatype in the model. So, the input must have a userID field with a string, a datetime field with a number, an active key with a boolean and the address field must be a dictionary which itself contains city, region and country values. Since it is empty, postal_code is optional. If a value is provided for postal_code however, it must be a string.] In addition to intuitive self-valid schema declarations, jsonModel also offers a rich way to further refine the conditionality of any property in the model through an accompanying components map whose key names correspond to the path to the schema property which requires additional validation:: { \"schema\": { ... }, \"components\": { \"userID\": { \"min_length\": 13, \"max_length\": 13, \"must_not_contain\": [ \"[^\\\\w]\", \"_\" ] }, \"address.city\": { \"discrete_values\": [ \"New Orleans\", \"New York\", \"Los Angeles\", \"Miami\" ], \"required_field\": false } } } [In this model, the process of checking the inputs will also check the paths designated in the components dictionary to make sure that values do not violate any of the additional attributes of the property declared in the components. Whenever they may conflict with the attributes declared in the schema example, the conditions in the components map supersedes. So, in this case, the requirement that an address contain a city key-value has been turned off. But if a city is provided, it must match one of the four city values provided. Likewise, any value provided in userID must be no more than nor less than 13 characters long and can only be composed of alphanumerical characters.] This module also validates the architecture of the model declarations themselves to facilitate the model design process and ensure that no models break the rules of the module. Error reports are provided to identity the scope of conditionals applicable to any given property in addition to the module documentation. To declare the model:: { \"schema\": { \"property\": \"value\" }, \"components\": {}, \"title\": \"my cool data model\", \"description\": \"model for performance analytics records of my sweet app\", \"metadata\": { \"version\": \"1.1.1\" }, \"url\": \"https://collectiveacuity.com/api/mycoolresource?jsonmodel=true\", \"max_size\": 1024, } [all fields except schema are optional] To import the schema:: import json sample_schema = json.loads(open('sample-schema.json').read()) To initialize the class object:: from jsonmodel.validators import jsonModel valid_model = jsonModel(sample_schema) To validate input against model declaration:: valid_model.validate(input) To validate input against an individual component:: path_to_root = 'dot.path[2].field' valid_model.validate(input, path_to_root) To handle invalid inputs:: try: valid_model.validate(invalid_input) except InputValidationError as err: assert err.error['error_code'] > 4000 To generate a colloquial explanation of error:: try: valid_model.validate(invalid_input) except InputValidationError as err: print(err.explain()) To customize error message:: input_title = 'Property field in input' valid_model.validate(input, path_to_root, input_title) To filter valid input based upon query criteria:: query_criteria = { 'dot.path[2].field': 'exact value' } assert valid_model.query(query_criteria, valid_input) query_criteria = { 'dot.path[2].field': { 'excluded_values': [ 'exact value' ] } } assert not valid_model.query(query_criteria, valid_input) To produce html documentation of model criteria:: from jsonmodel.extensions import tabulate tabulate(valid_model) html_table = valid_model.tabulate() Further Reading For more details about how to use the jsonModel class, refer to the jsonModel Class , Reference , Extensions and Roadmap pages.","title":"Home"},{"location":"#json-model","text":"A Collection of Methods for Validating JSON Structured Data by Collective Acuity Downloads http://pypi.python.org/pypi/jsonModel Source https://github.com/collectiveacuity/jsonModel Documentation https://collectiveacuity.github.io/jsonModel/","title":"Json Model"},{"location":"#introduction","text":"Json Model is designed to facilitate the process of implementing data validation against a declared json data model. The jsonModel class offers a more intuitive declaration process than other schema enforcement modules currently available by relying upon the architecture of json itself to validate datatypes, requirements and defaults.","title":"Introduction"},{"location":"#installation","text":"From PyPi:: $ pip install jsonmodel From GitHub:: $ git clone https://github.com/collectiveacuity/jsonmodel $ cd jsonmodel $ python setup.py install","title":"Installation"},{"location":"#getting-started","text":"This module uses self-valid schema declarations as a method to describe data requirements. As a result, for many data models, full validation can be achieved from an example declaration using the schema key:: { \"schema\": { \"userID\": \"gY3Cv81QwL0Fs\", \"datetime\": 1456000345.543713, \"active\": true, \"address\": { \"city\": \"New Orleans\", \"region\": \"LA\", \"postal_code\": \"\", \"country\": \"United States\" } } } [In this model, the input must contain values for all four top level keys and each value must correspond to the datatype in the model. So, the input must have a userID field with a string, a datetime field with a number, an active key with a boolean and the address field must be a dictionary which itself contains city, region and country values. Since it is empty, postal_code is optional. If a value is provided for postal_code however, it must be a string.] In addition to intuitive self-valid schema declarations, jsonModel also offers a rich way to further refine the conditionality of any property in the model through an accompanying components map whose key names correspond to the path to the schema property which requires additional validation:: { \"schema\": { ... }, \"components\": { \"userID\": { \"min_length\": 13, \"max_length\": 13, \"must_not_contain\": [ \"[^\\\\w]\", \"_\" ] }, \"address.city\": { \"discrete_values\": [ \"New Orleans\", \"New York\", \"Los Angeles\", \"Miami\" ], \"required_field\": false } } } [In this model, the process of checking the inputs will also check the paths designated in the components dictionary to make sure that values do not violate any of the additional attributes of the property declared in the components. Whenever they may conflict with the attributes declared in the schema example, the conditions in the components map supersedes. So, in this case, the requirement that an address contain a city key-value has been turned off. But if a city is provided, it must match one of the four city values provided. Likewise, any value provided in userID must be no more than nor less than 13 characters long and can only be composed of alphanumerical characters.] This module also validates the architecture of the model declarations themselves to facilitate the model design process and ensure that no models break the rules of the module. Error reports are provided to identity the scope of conditionals applicable to any given property in addition to the module documentation. To declare the model:: { \"schema\": { \"property\": \"value\" }, \"components\": {}, \"title\": \"my cool data model\", \"description\": \"model for performance analytics records of my sweet app\", \"metadata\": { \"version\": \"1.1.1\" }, \"url\": \"https://collectiveacuity.com/api/mycoolresource?jsonmodel=true\", \"max_size\": 1024, } [all fields except schema are optional] To import the schema:: import json sample_schema = json.loads(open('sample-schema.json').read()) To initialize the class object:: from jsonmodel.validators import jsonModel valid_model = jsonModel(sample_schema) To validate input against model declaration:: valid_model.validate(input) To validate input against an individual component:: path_to_root = 'dot.path[2].field' valid_model.validate(input, path_to_root) To handle invalid inputs:: try: valid_model.validate(invalid_input) except InputValidationError as err: assert err.error['error_code'] > 4000 To generate a colloquial explanation of error:: try: valid_model.validate(invalid_input) except InputValidationError as err: print(err.explain()) To customize error message:: input_title = 'Property field in input' valid_model.validate(input, path_to_root, input_title) To filter valid input based upon query criteria:: query_criteria = { 'dot.path[2].field': 'exact value' } assert valid_model.query(query_criteria, valid_input) query_criteria = { 'dot.path[2].field': { 'excluded_values': [ 'exact value' ] } } assert not valid_model.query(query_criteria, valid_input) To produce html documentation of model criteria:: from jsonmodel.extensions import tabulate tabulate(valid_model) html_table = valid_model.tabulate()","title":"Getting Started"},{"location":"#further-reading","text":"For more details about how to use the jsonModel class, refer to the jsonModel Class , Reference , Extensions and Roadmap pages.","title":"Further Reading"},{"location":"extensions/","text":"Extensions a package of extensions to a jsonModel class object tabulate Import: jsonmodel.extensions Initialize:: from jsonmodel.extensions import tabulate json_model = jsonModel(sample_schema) tabulate(json_model) Signature: tabulate(self, format=\u201dhtml\u201d, syntax=\u201d\u201c) Description: a function to create a table from the class model keyMap Argument Type Required Default Description self object Yes None format str \"html\" string with format for table output syntax str \"\" [optional] string with linguistic syntax","title":"Extensions"},{"location":"extensions/#extensions","text":"a package of extensions to a jsonModel class object","title":"Extensions"},{"location":"extensions/#tabulate","text":"","title":"tabulate"},{"location":"extensions/#_1","text":"Import: jsonmodel.extensions","title":""},{"location":"extensions/#_2","text":"Initialize:: from jsonmodel.extensions import tabulate json_model = jsonModel(sample_schema) tabulate(json_model)","title":""},{"location":"extensions/#_3","text":"Signature: tabulate(self, format=\u201dhtml\u201d, syntax=\u201d\u201c)","title":""},{"location":"extensions/#_4","text":"Description: a function to create a table from the class model keyMap Argument Type Required Default Description self object Yes None format str \"html\" string with format for table output syntax str \"\" [optional] string with linguistic syntax","title":""},{"location":"jsonmodel/","text":"jsonModel Class The jsonModel class is the main class of the module. A jsonModel object must be initialized with a json-valid dictionary with the schema you wish to valid. When the object is initialized, it validates the architecture of the model declaration itself to facilitate the model design process and ensure that no models break the rules of the module. Once a valid model is constructed, input can then be fed to the class method \u2018validate\u2019 to determine whether the input is valid. Error reports are provided to identify the scope of conditionals applicable to any given property in addition to the module documentation. Declare Schema Save in sample-schema.json:: { \"schema\": { \"property\": \"value\" }, \"components\": {}, \"title\": \"my cool data model\", \"description\": \"model for performance analytics records of my sweet app\", \"metadata\": { \"version\": \"1.1.1\" }, \"url\": \"https://collectiveacuity.com/api/mycoolresource?jsonmodel=true\", \"max_size\": 1024, } [all fields except schema are optional] Import Schema To import the schema:: import json sample_schema = json.loads(open('sample-schema.json').read()) Initialize Model To initialize the class object:: from jsonmodel.validators import jsonModel valid_model = jsonModel(sample_schema) Validate Input To validate input against model declaration:: valid_model.validate(input) To validate input against an individual component:: path_to_root = '.property' valid_model.validate(input, path_to_root) Handle Errors To handle invalid inputs:: try: valid_model.validate(invalid_input) except InputValidationError as err: assert err.error['error_code'] > 4000 To customize error message: input_title = 'Property field in input' valid_model.validate(input, path_to_root, input_title) Ingest Kwargs This module also supports the ingestion of keyword arguments. The process of ingestion recursively walks the valid model searching for key-value pairs which match the keyword arguments of the input. For each match it finds, it constructs a key-value pair in the dictionary using the following rules (in order): Value in kwargs if field passes all its component validation tests Default value declared for the key in the model Empty value appropriate to datatype of key in the model As a result, ingestion will produce an output which contains all the keys declared in the model. If there is a default value declared for each key in the model, it is also guaranteed to return a dictionary that will pass a model validation test. Extra keyword arguments are ignored unless extra fields is True in the model declaration. To ingest kwargs:: output_dict = valid_model.ingest(**kwargs) To produce a default record: default_dict = valid_model.ingest() Use Declared Another way to guarantee an ingestion will return a dictionary that will pass a model validation test is by using the use_declared method before ingestion. use_declared will automatically assign the declared value to any key in the schema without a \u201cdefault_value\u201d qualifier. To produce a default record with declared values instead: valid_model.use_declared() declared_dict = valid_model.ingest() Query Records The jsonModel class also supports record querying on model validated data. When the model is initialized, it constructs a set of operators that can be used to query records which contain data validated by the model. The set of valid operators and qualifiers which can be used to query records on each field depend upon its datatype. The query criteria for each field is the subset of the criteria that can be declared for that field in the components section of the model which can evaluate to \u2018true\u2019 against a value stored for that field in a record. The built in query method supports any number of fields declared in the model as well as the maximum subset of query relevant criteria for each field based upon its datatype. But the model can also be initialized with a customized dictionary of rules for field datatypes based upon what is supported by a specific query engine. In this way, the query method can be used as a bridge across multiple different database query languages (with a jsonModel valid record access object customized for applicable databases) or as a post-request filter for records stored in a way that does not support robust query criteria. To declare query rules:: { \".string_fields\": { \"must_contain\": [] } } To initialize model with custom query rules:: query_rules = json.loads(open('query-rules.json').read()) valid_model = jsonModel(sample_model, query_rules) To declare query criteria:: { 'dot.path[2].field': { 'must_contain': [ 'v.+' ] } } To validate query criteria:: valid_model.query(sample_query) To evaluate a record using the criteria:: valid_input = valid_model.validate(input) eval_outcome = valid_model.query(sample_query, valid_input) assert isinstance(eval_outcome, bool)","title":"jsonModel Class"},{"location":"jsonmodel/#jsonmodel-class","text":"The jsonModel class is the main class of the module. A jsonModel object must be initialized with a json-valid dictionary with the schema you wish to valid. When the object is initialized, it validates the architecture of the model declaration itself to facilitate the model design process and ensure that no models break the rules of the module. Once a valid model is constructed, input can then be fed to the class method \u2018validate\u2019 to determine whether the input is valid. Error reports are provided to identify the scope of conditionals applicable to any given property in addition to the module documentation.","title":"jsonModel Class"},{"location":"jsonmodel/#declare-schema","text":"Save in sample-schema.json:: { \"schema\": { \"property\": \"value\" }, \"components\": {}, \"title\": \"my cool data model\", \"description\": \"model for performance analytics records of my sweet app\", \"metadata\": { \"version\": \"1.1.1\" }, \"url\": \"https://collectiveacuity.com/api/mycoolresource?jsonmodel=true\", \"max_size\": 1024, } [all fields except schema are optional]","title":"Declare Schema"},{"location":"jsonmodel/#import-schema","text":"To import the schema:: import json sample_schema = json.loads(open('sample-schema.json').read())","title":"Import Schema"},{"location":"jsonmodel/#initialize-model","text":"To initialize the class object:: from jsonmodel.validators import jsonModel valid_model = jsonModel(sample_schema)","title":"Initialize Model"},{"location":"jsonmodel/#validate-input","text":"To validate input against model declaration:: valid_model.validate(input) To validate input against an individual component:: path_to_root = '.property' valid_model.validate(input, path_to_root)","title":"Validate Input"},{"location":"jsonmodel/#handle-errors","text":"To handle invalid inputs:: try: valid_model.validate(invalid_input) except InputValidationError as err: assert err.error['error_code'] > 4000 To customize error message: input_title = 'Property field in input' valid_model.validate(input, path_to_root, input_title)","title":"Handle Errors"},{"location":"jsonmodel/#ingest-kwargs","text":"This module also supports the ingestion of keyword arguments. The process of ingestion recursively walks the valid model searching for key-value pairs which match the keyword arguments of the input. For each match it finds, it constructs a key-value pair in the dictionary using the following rules (in order): Value in kwargs if field passes all its component validation tests Default value declared for the key in the model Empty value appropriate to datatype of key in the model As a result, ingestion will produce an output which contains all the keys declared in the model. If there is a default value declared for each key in the model, it is also guaranteed to return a dictionary that will pass a model validation test. Extra keyword arguments are ignored unless extra fields is True in the model declaration. To ingest kwargs:: output_dict = valid_model.ingest(**kwargs) To produce a default record: default_dict = valid_model.ingest()","title":"Ingest Kwargs"},{"location":"jsonmodel/#use-declared","text":"Another way to guarantee an ingestion will return a dictionary that will pass a model validation test is by using the use_declared method before ingestion. use_declared will automatically assign the declared value to any key in the schema without a \u201cdefault_value\u201d qualifier. To produce a default record with declared values instead: valid_model.use_declared() declared_dict = valid_model.ingest()","title":"Use Declared"},{"location":"jsonmodel/#query-records","text":"The jsonModel class also supports record querying on model validated data. When the model is initialized, it constructs a set of operators that can be used to query records which contain data validated by the model. The set of valid operators and qualifiers which can be used to query records on each field depend upon its datatype. The query criteria for each field is the subset of the criteria that can be declared for that field in the components section of the model which can evaluate to \u2018true\u2019 against a value stored for that field in a record. The built in query method supports any number of fields declared in the model as well as the maximum subset of query relevant criteria for each field based upon its datatype. But the model can also be initialized with a customized dictionary of rules for field datatypes based upon what is supported by a specific query engine. In this way, the query method can be used as a bridge across multiple different database query languages (with a jsonModel valid record access object customized for applicable databases) or as a post-request filter for records stored in a way that does not support robust query criteria. To declare query rules:: { \".string_fields\": { \"must_contain\": [] } } To initialize model with custom query rules:: query_rules = json.loads(open('query-rules.json').read()) valid_model = jsonModel(sample_model, query_rules) To declare query criteria:: { 'dot.path[2].field': { 'must_contain': [ 'v.+' ] } } To validate query criteria:: valid_model.query(sample_query) To evaluate a record using the criteria:: valid_input = valid_model.validate(input) eval_outcome = valid_model.query(sample_query, valid_input) assert isinstance(eval_outcome, bool)","title":"Query Records"},{"location":"reference/","text":"Reference Materials Documentation for model declaration and error handling for jsonModel validation Schema Default Behavior The default behavior of a schema declaration includes validation of structure, datatype and requirements. Any of these defaults can be turned off in the specification of a field in the components map. However, for many purposes, the defaults will suffice to declare model field validation, eliminating the need for further specification in a components map. Schema Example :: \"schema\": { \"userID\": \"gY3Cv81QwL0Fs\", \"datetime\": 1456000345.543713, \"active\": true, \"emoticon\": \"aGFwcHk=\", \"rating\": 8, \"reference\": null, \"address\": { \"city\": \"New Orleans\", \"region\": \"LA\", \"postal_code\": \"\", \"country\": \"United States\", \"country_code\": 0 }, \"comments\": [ \"@GerardMaras Rock the shrimp bouillabaisse!\" ] } Default Settings Structure : The validation process will assume that a dictionary (including the top-level dictionary) defines its maximum scope of key names and that lists can contain any number of items. Lists cannot contain mixed datatypes and the first item in a list defines the allowable properties of each item in the list. For this reason, all lists declared in the model must also contain an item. So, the example model expects to find only the userID, datetime, active, emoticon, rating, address and comments fields and it will accept any number of strings in the comments list. Datatype : The validation process will assume that the datatype of each value in the input matches the datatype in the model. So, the example model expects to see a string for userID, a number for datetime, a boolean for active, etc\u2026 Special datatypes like bytes, integers and sets which json does not directly support must be handled by qualifiers in the components map. Requirements : The validation process will assume a key with a non-empty value is a required input. Since lists must declare an item, all lists are assumed to be required fields in the model. So, all fields in the example are required except postal_code and country_code. The empty value for each datatype can be expressed with {}, 0, 0.0, false or \u201c\u201d and indicates that it is optional. Meta-Model Restrictions A model validation error will occur if a key name in the schema contains an item designator pattern such as [2] or [35]. The module uses these patterns to validate inputs which contain lists of arbitrary size. As a result, there are limitations to the meta-model recursion of the module. It is not possible to use lists in model declarations which you wish to use as schemas in other model declarations. Components Map The default validation process can be modified, and other (less common) conditional qualifier can be added through the components map of the model. Whereas the schema map provides a transparent data architecture that is self-valid, the components map can be used to specify the conditions of acceptable data for any number of fields in the schema. The component map is an optional flat dictionary where each key in the component map designates a particular path in the schema using the dot-path (\u2018.\u2019 and [0]) nomenclature of nesting and array identification. Components Example :: \"components\": { \".\": { \"extra_fields\": false, \"min_size\": 10, \"max_size\": 300 }, \".active\": { \"equal_to\": false }, \".userID\": { \"min_length\": 13, \"max_length\": 13, \"min_value\": \"1111111111111\", \"max_value\": \"yyyyyyyyyyyyy\", \"must_not_contain\": [ \"[^\\\\w]\", \"_\" ], \"field_description\": \"13 digit unique base 64 url safe key\" }, \".datetime\": { \"greater_than\": 1.1, \"less_than\": 2000000000.0, \"field_position\": 1 }, \".emoticon\": { \"required_field\": false, \"byte_data\": true, \"example_values\": [ \"aGFwcHk=\" ], \"excluded_values\": [ \"c2Fk\" ], \"field_metadata\": { \"endpoint\": \"http://collectiveacuity.com/icons/\" } }, \".reference\": { \"required_field\": false }, \".rating\": { \"required_field\": false, \"min_value\": 1, \"max_value\": 10, \"default_value\": 5, \"excluded_values\": [ 7, 9 ], \"integer_data\": true }, \".address.city\": { \"discrete_values\": [ \"New Orleans\", \"New York\", \"Los Angeles\", \"Miami\" ], \"required_field\": false, \"default_value\": \"New York\" }, \".address.region\":{ \"greater_than\": \"AB\", \"less_than\": \"Yyyyyyyyyyyyyyyyyyyyyyyy\", \"contains_either\": [ \"[A-Z]{2}\", \"[A-Z][a-z]+\" ], \"field_title\": \"State or Province\" }, \".address.country_code\":{ \"discrete_values\": [ 36, 124, 554, 826, 840 ], \"integer_data\": true }, \".comments\": { \"required_field\": false, \"min_size\": 1, \"max_size\": 3, \"unique_values\": true } \".comments[0]\": { \"max_length\": 140, \"must_contain\": [ \"[a-zA-Z]{2,}\" ], \"example_values\": [ \"couldn't find the place\", \"hidden gem!!!!\" ] } } Path Definitions To validate additional conditional qualifier placed on a field in the schema, the validation process looks through the schema for the value associated with a key or item specified in the key name of the components map. In this example, the key named \u201c.userID\u201d maps to the \u201cuserID\u201d key to be found in the top level map of the schema, \u201c.address.city\u201d refers to the \u201ccity\u201d key inside the \u201caddress\u201d map inside the schema map and \u201c.comments[0]\u201d refers to the first item inside the comments list. Since the comments list is itself made optional by the declaration \u201crequired_field\u201d: false in the \u201c.comments\u201d key, this component is only validated if there is an item to validate. Otherwise, it is ignored. \u201c.\u201d is the key name for the top-level map itself and the \u201cextra_fields\u201d criterion changes the default to allow the top-level map to accept undeclared keys. NOTE: The \u201c.\u201d at the beginning of a dot-path is optional. So, a key named \u201cuserID\u201d is the same as \u201c.userID\u201d. List of Field Conditionals Criteria Key Criteria Value Error Code String Number Boolean Map List Status Description value_datatype String n/a available the datatype of a value or item defined in the schema required_field Boolean 4002 Y Y Y Y Y available a true boolean requires this key-value in the input extra_fields Boolean 4003 Y available a true boolean allows map to contain undeclared keys key_datatype String n/a available the datatype of a key name must be a string maximum_scope List n/a available the maximum extent of keys allowed in a dictionary generated by extra_fields default declared_value Any n/a available the value or item defined in the schema [strings default_value Any n/a Y Y Y Y available a value for an optional field when field is missing in input byte_data Boolean 4011 Y available a true boolean expects to see base64 byte data in the string field min_length Integer 4012 Y available the minimum number of characters in a string max_length Integer 4013 Y available the maximum number of characters in a string must_not_contain List of Strings 4014 Y available a list of regular expressions which should not be found in a string must_contain List of Strings 4015 Y available a list of regular expressions which must be found in a string contains_either List of Strings 4016 Y available a list of regular expressions which string must match at least one integer_data Boolean 4021 Y available a true boolean requires number to be an integer min_value Number or String 4022 Y Y available the minimum value of a number or string max_value Number or String 4023 Y Y available the maximum value of a number or string greater_than Number or String 4024 Y Y available the value a number or string must be greater than less_than Number or String 4025 Y Y available the value a number or string must be less than equal_to Boolean, Number or String 4026 Y Y Y available the value a number, string or boolean must equal min_size Integer 4031 Y Y available the minimum size of a map converted to json data or the minimum number of items in a list max_size Integer 4032 Y Y available the maximum size of a map converted to json data or the maximum number of items in a list unique_values Boolean 4033 Y available a true boolean treats a list as a set of unique primitives with no duplication discrete_values List of Strings or Numbers 4041 Y Y available a list of values allowed identical_to String Y Y Y Y Y the key name in the components map whose value the value of this component must match lambda_function String Y Y Y Y Y a single argument function which should be run to validate the value of this component / lambda_function must return true (valid) or false (invalid) validation_url String Y Y Y Y Y an uri which can be called to validate the value of this component with its input in the body of the request / uri response must return true (valid) or false (invalid) valid_path Boolean Y a true value will check localhost to determine if file path is valid example_values List of Strings or Numbers Y Y available a list of values which satisfy all the validation requirements field_title String n/a Y Y Y Y Y available the title of the component for documentation and error reporting field_description String n/a Y Y Y Y Y available a description of the component for documentation and error reporting field_position Integer n/a Y Y Y Y Y available the position of the component in an ordered array of fields field_metadata Map n/a Y Y Y Y Y available a dictionary for metadata about the component that passes through validation check Error Handling Errors created from improper model specification will raise a ModelValidationError with a message that is designed to help determine the source of the model declaration error. To ensure that model initialization occurs properly, no error encoding is included to handle these exceptions. However, it is expected that validation of inputs will produce errors. Otherwise, what\u2019s the point?! So, in addition to a text report, a dictionary has been included with the InputValidationError exception to facilitate error handling. Error Method Example :: self.error = { 'model_schema': { 'datetime': 1456190345.543713, 'address': { 'country_code': 0, 'city': 'New Orleans', 'postal_code': '', 'region': 'LA', 'country': 'United States' }, 'comments': [ '@GerardMaras Rock the shrimp bouillabaisse!' ], 'active': True, 'rating': 8, 'reference': None, 'userID': 'gY3Cv81QwL0Fs', 'emoticon': 'aGFwcHk=', }, 'input_path': '.', 'input_criteria': { 'required_field': True, 'value_datatype': 'map', 'min_size': 10, 'max_size': 300, 'maximum_scope': [ 'datetime', 'address', 'active', 'userID', 'comments', 'rating', 'emoticon' ], 'extra_fields': False }, 'failed_test': 'extra_fields', 'error_value': 'extraKey', 'error_code': 4003 } Order of Exceptions The validation process will raise an error as soon as it encounters one, so there is no guarantee that the error that is reported is the only error in the input. Since there is no set order to the keys in a dictionary, there is also no guaranteed a priori order to the evaluation process. However below is an overview of the order of the steps of the validation process: Structure: Input is a dictionary Required keys in the input Extra keys in the input Value of each key in the input (recursive) (see below) Inject default values for missing optional keys Values (or Items): Datatype of value Other value qualifiers based upon datatype Identity, Lambda and URL qualifiers # TODO To help the process of error handling and client-server negotiation, both the schema for the model as well as the the map of conditional qualifiers for the field that raised the error are included in the error dictionary. Ingesting Kwargs The process of ingestion recursively walks the valid model searching for key-value pairs which match the keyword arguments of the input. For each match it finds, it constructs a key-value pair in the dictionary using the following rules (in order): Value in kwargs if field passes all its component validation tests Default value declared for the key in the model Empty value appropriate to datatype of key in the model Like the core validation method, ingestion will also walk through each item in a list field of the kwargs if the item type itself is also a list or dictionary. However, because invalid data will be replaced by empty values appropriate to the datatype declared in the model, unlike the core validation model, output data from ingest may not be model valid data. If it is desirable to ensure that the data is valid, a \u2018default_value\u2019 should be declared for each key in the components section of the data model and the \u2018min_size\u2019 of each list declaration should only be set to 0. Sample Kwargs :: { \"userID\": \"6nPbM9gTwLz3f\", \"datetime\": 1449179763.312077, \"active\": false, \"emoticon\": \"aGFwcHIk=\", \"comments\": [ \"gold\", \"silver\", \"bronze\", \"pewter\" ], \"address\": { \"region\": \"NY\", \"country\": \"United States\" } } Ingest Sample :: output = jsonModel.ingest(**sample_kwargs) Sample Output :: { 'userID': '6nPbM9gTwLz3f', 'datetime': 1449179763.312077, 'active': False, 'rating': 5, 'reference': None, 'emoticon': 'aGFwcHIk=' 'comments': ['gold', 'silver', 'bronze'], 'address': { 'postal_code': '', 'city': 'New York', 'country_code': 0, 'region': 'NY', 'country': 'United States' } } Ingest Empty :: output = jsonModel.ingest(**{}) Empty Output :: { 'userID': '', 'datetime': 0.0, 'active': False, 'rating': 5, 'reference': None, 'emoticon': '' 'comments': [], 'address': { 'postal_code': '', 'city': 'New York', 'country_code': 0, 'region': '', 'country': '' } } Extra Keywords If \u2018extra_fields\u2019 is declared True in the components for a dictionary in the model, then any extraneous keys in the corresponding dictionary in the kwargs will be added to the output. Too Many Items Items are only added to a list from those items in kwargs if they are valid. If the number of valid items in a list in the kwargs exceeds the \u2018max_size\u2019 of the corresponding list in the model, then subsequent items are not added to the list once the list reaches its maximum size. Query Criteria Query criteria are composed of a dictionary of one or more key-value pairs, where the key names are the dot path to the fields in the model schema to be queried and the values are dictionaries containing any of the conditional operators for the query on the respective fields. Like component declarations, the \u201c.\u201d at the beginning of the dot path for a key name is optional. For fields with number, string or boolean datatypes, { \u201cfield\u201d: { \u201cequal_to\u201d: \u201cvalue\u201d } } can be shortened to { \u201cfield\u201d: \u201cvalue\u201d } and the class will automatically interpret the syntax as the \u201cequal_to\u201d criteria. Query criteria can be simple, such as the single field, operator and qualifier in the example in Home , or elaborate, such as found in the provided model sample-query.json below: Sample Query :: { \".active\": { \"value_exists\": true, \"equal_to\": false }, \".address\": { \"max_size\": 100 }, \".address.country\": \"United States\", \".address.city\": { \"discrete_values\": [ \"New Orleans\", \"New York\", \"Los Angeles\", \"Miami\"] }, \".address.country_code\": { \"discrete_values\": [36, 124, 554, 826, 840], \"integer_data\": true }, \".address.region\": { \"contains_either\": [\"[A-Z]{2}\", \"[A-Z][a-z]+\"], \"greater_than\": \"AB\", \"less_than\": \"Yyyyyyyyyyyyyyyyyyyyyyyy\" }, \".comments\": { \"max_size\": 3, \"min_size\": 1, \"unique_values\": true }, \".comments[0]\": { \"max_length\": 140, \"must_contain\": [\"[a-zA-Z]{2,}\"] }, \".datetime\": { \"greater_than\": 1.1, \"less_than\": 2000000000.0 }, \".emoticon\": { \"byte_data\": true, \"excluded_values\": [\"c2Fk\"] }, \".rating\": { \"excluded_values\": [7, 9], \"max_value\": 10, \"min_value\": 1 }, \".userID\": { \"max_length\": 13, \"max_value\": \"yyyyyyyyyyyyy\", \"min_length\": 13, \"min_value\": \"1111111111111\", \"must_not_contain\": [\"[^\\\\w]\", \"_\"] } } The query method follows a similar process by which input is validated. A record whose field values evaluate to true for all criteria returns true. Otherwise, something in the record does not match one or more query criteria and the query method returns false. Because the query method returns a false as soon as it encounters a failed criteria from a dictionary of fields in the query criteria, query time will vary based upon the number of records, how many fail and how many fields are added to the query criteria. Querying Items Although the query method will evaluate items nested inside lists to an arbitrary depth, it does so by evaluating all items in the list and all sub-branches of any nested lists inside the list. As a result, querying items inside lists suffers non-linear explosion. And, unlike the process of item ingestion, if any item in a list (or branch of a sub-list) evaluates to true to the criteria provided the entire list will evaluate to true. Be Warned Query Errors If query criteria contain fields, operators or qualifiers which are outside the scope of the model, the query method will produce a QueryValidationError. To handle a QueryValidationError:: try: query_results = validModel.query(invalid_criteria, test_record) except QueryValidationError as err: assert isinstance(err.error['message'], str) Query Rules Customization When the model is initialized, it accepts an optional dictionary for customized query rules. The primary purpose of this customization is to limit query criteria validation to only those query operations which are supported by a specific query engine. Optional query rules must be structured according to the components field of the model-rules.json file and cannot contain any fields, operators or qualifiers outside the full range of the model query rules. Query Rules :: { \".boolean_fields\": { \"identical_to\": \".similar_boolean\", \"lambda_function\": \"\", \"validation_url\": \"\", \"value_exists\": false, \"equal_to\": false }, \".list_fields\": { \"identical_to\": \".similar_list\", \"lambda_function\": \"\", \"max_size\": 0, \"min_size\": 0, \"unique_values\": false, \"validation_url\": \"\", \"value_exists\": false }, \".map_fields\": { \"identical_to\": \".similar_map\", \"lambda_function\": \"\", \"max_size\": 0, \"min_size\": 0, \"validation_url\": \"\", \"value_exists\": false }, \".null_fields\": { \"identical_to\": \".similar_null\", \"lambda_function\": \"\", \"validation_url\": \"\", \"value_exists\": false }, \".number_fields\": { \"discrete_values\": [], \"excluded_values\": [], \"greater_than\": 0.0, \"identical_to\": \".similar_number\", \"integer_data\": false, \"lambda_function\": \"\", \"less_than\": 0.0, \"max_value\": 0.0, \"min_value\": 0.0, \"validation_url\": \"\", \"value_exists\": false, \"equal_to\": 0.0 }, \".string_fields\": { \"byte_data\": false, \"contains_either\": [], \"discrete_values\": [], \"excluded_values\": [], \"greater_than\": \"\", \"identical_to\": \".similar_string\", \"lambda_function\": \"\", \"less_than\": \"\", \"max_length\": 0, \"max_value\": \"\", \"min_length\": 0, \"min_value\": \"\", \"must_contain\": [], \"must_not_contain\": [], \"validation_url\": \"\", \"value_exists\": false, \"equal_to\": \"\" } } [The lambda_function, identical_to and validation_url operators are not yet supported by the model.] A malformed query rules argument on model initialization will produce a ModelValidationError.","title":"Reference"},{"location":"reference/#reference-materials","text":"Documentation for model declaration and error handling for jsonModel validation","title":"Reference Materials"},{"location":"reference/#schema-default-behavior","text":"The default behavior of a schema declaration includes validation of structure, datatype and requirements. Any of these defaults can be turned off in the specification of a field in the components map. However, for many purposes, the defaults will suffice to declare model field validation, eliminating the need for further specification in a components map. Schema Example :: \"schema\": { \"userID\": \"gY3Cv81QwL0Fs\", \"datetime\": 1456000345.543713, \"active\": true, \"emoticon\": \"aGFwcHk=\", \"rating\": 8, \"reference\": null, \"address\": { \"city\": \"New Orleans\", \"region\": \"LA\", \"postal_code\": \"\", \"country\": \"United States\", \"country_code\": 0 }, \"comments\": [ \"@GerardMaras Rock the shrimp bouillabaisse!\" ] }","title":"Schema Default Behavior"},{"location":"reference/#default-settings","text":"Structure : The validation process will assume that a dictionary (including the top-level dictionary) defines its maximum scope of key names and that lists can contain any number of items. Lists cannot contain mixed datatypes and the first item in a list defines the allowable properties of each item in the list. For this reason, all lists declared in the model must also contain an item. So, the example model expects to find only the userID, datetime, active, emoticon, rating, address and comments fields and it will accept any number of strings in the comments list. Datatype : The validation process will assume that the datatype of each value in the input matches the datatype in the model. So, the example model expects to see a string for userID, a number for datetime, a boolean for active, etc\u2026 Special datatypes like bytes, integers and sets which json does not directly support must be handled by qualifiers in the components map. Requirements : The validation process will assume a key with a non-empty value is a required input. Since lists must declare an item, all lists are assumed to be required fields in the model. So, all fields in the example are required except postal_code and country_code. The empty value for each datatype can be expressed with {}, 0, 0.0, false or \u201c\u201d and indicates that it is optional.","title":"Default Settings"},{"location":"reference/#meta-model-restrictions","text":"A model validation error will occur if a key name in the schema contains an item designator pattern such as [2] or [35]. The module uses these patterns to validate inputs which contain lists of arbitrary size. As a result, there are limitations to the meta-model recursion of the module. It is not possible to use lists in model declarations which you wish to use as schemas in other model declarations.","title":"Meta-Model Restrictions"},{"location":"reference/#components-map","text":"The default validation process can be modified, and other (less common) conditional qualifier can be added through the components map of the model. Whereas the schema map provides a transparent data architecture that is self-valid, the components map can be used to specify the conditions of acceptable data for any number of fields in the schema. The component map is an optional flat dictionary where each key in the component map designates a particular path in the schema using the dot-path (\u2018.\u2019 and [0]) nomenclature of nesting and array identification. Components Example :: \"components\": { \".\": { \"extra_fields\": false, \"min_size\": 10, \"max_size\": 300 }, \".active\": { \"equal_to\": false }, \".userID\": { \"min_length\": 13, \"max_length\": 13, \"min_value\": \"1111111111111\", \"max_value\": \"yyyyyyyyyyyyy\", \"must_not_contain\": [ \"[^\\\\w]\", \"_\" ], \"field_description\": \"13 digit unique base 64 url safe key\" }, \".datetime\": { \"greater_than\": 1.1, \"less_than\": 2000000000.0, \"field_position\": 1 }, \".emoticon\": { \"required_field\": false, \"byte_data\": true, \"example_values\": [ \"aGFwcHk=\" ], \"excluded_values\": [ \"c2Fk\" ], \"field_metadata\": { \"endpoint\": \"http://collectiveacuity.com/icons/\" } }, \".reference\": { \"required_field\": false }, \".rating\": { \"required_field\": false, \"min_value\": 1, \"max_value\": 10, \"default_value\": 5, \"excluded_values\": [ 7, 9 ], \"integer_data\": true }, \".address.city\": { \"discrete_values\": [ \"New Orleans\", \"New York\", \"Los Angeles\", \"Miami\" ], \"required_field\": false, \"default_value\": \"New York\" }, \".address.region\":{ \"greater_than\": \"AB\", \"less_than\": \"Yyyyyyyyyyyyyyyyyyyyyyyy\", \"contains_either\": [ \"[A-Z]{2}\", \"[A-Z][a-z]+\" ], \"field_title\": \"State or Province\" }, \".address.country_code\":{ \"discrete_values\": [ 36, 124, 554, 826, 840 ], \"integer_data\": true }, \".comments\": { \"required_field\": false, \"min_size\": 1, \"max_size\": 3, \"unique_values\": true } \".comments[0]\": { \"max_length\": 140, \"must_contain\": [ \"[a-zA-Z]{2,}\" ], \"example_values\": [ \"couldn't find the place\", \"hidden gem!!!!\" ] } }","title":"Components Map"},{"location":"reference/#path-definitions","text":"To validate additional conditional qualifier placed on a field in the schema, the validation process looks through the schema for the value associated with a key or item specified in the key name of the components map. In this example, the key named \u201c.userID\u201d maps to the \u201cuserID\u201d key to be found in the top level map of the schema, \u201c.address.city\u201d refers to the \u201ccity\u201d key inside the \u201caddress\u201d map inside the schema map and \u201c.comments[0]\u201d refers to the first item inside the comments list. Since the comments list is itself made optional by the declaration \u201crequired_field\u201d: false in the \u201c.comments\u201d key, this component is only validated if there is an item to validate. Otherwise, it is ignored. \u201c.\u201d is the key name for the top-level map itself and the \u201cextra_fields\u201d criterion changes the default to allow the top-level map to accept undeclared keys. NOTE: The \u201c.\u201d at the beginning of a dot-path is optional. So, a key named \u201cuserID\u201d is the same as \u201c.userID\u201d.","title":"Path Definitions"},{"location":"reference/#list-of-field-conditionals","text":"Criteria Key Criteria Value Error Code String Number Boolean Map List Status Description value_datatype String n/a available the datatype of a value or item defined in the schema required_field Boolean 4002 Y Y Y Y Y available a true boolean requires this key-value in the input extra_fields Boolean 4003 Y available a true boolean allows map to contain undeclared keys key_datatype String n/a available the datatype of a key name must be a string maximum_scope List n/a available the maximum extent of keys allowed in a dictionary generated by extra_fields default declared_value Any n/a available the value or item defined in the schema [strings default_value Any n/a Y Y Y Y available a value for an optional field when field is missing in input byte_data Boolean 4011 Y available a true boolean expects to see base64 byte data in the string field min_length Integer 4012 Y available the minimum number of characters in a string max_length Integer 4013 Y available the maximum number of characters in a string must_not_contain List of Strings 4014 Y available a list of regular expressions which should not be found in a string must_contain List of Strings 4015 Y available a list of regular expressions which must be found in a string contains_either List of Strings 4016 Y available a list of regular expressions which string must match at least one integer_data Boolean 4021 Y available a true boolean requires number to be an integer min_value Number or String 4022 Y Y available the minimum value of a number or string max_value Number or String 4023 Y Y available the maximum value of a number or string greater_than Number or String 4024 Y Y available the value a number or string must be greater than less_than Number or String 4025 Y Y available the value a number or string must be less than equal_to Boolean, Number or String 4026 Y Y Y available the value a number, string or boolean must equal min_size Integer 4031 Y Y available the minimum size of a map converted to json data or the minimum number of items in a list max_size Integer 4032 Y Y available the maximum size of a map converted to json data or the maximum number of items in a list unique_values Boolean 4033 Y available a true boolean treats a list as a set of unique primitives with no duplication discrete_values List of Strings or Numbers 4041 Y Y available a list of values allowed identical_to String Y Y Y Y Y the key name in the components map whose value the value of this component must match lambda_function String Y Y Y Y Y a single argument function which should be run to validate the value of this component / lambda_function must return true (valid) or false (invalid) validation_url String Y Y Y Y Y an uri which can be called to validate the value of this component with its input in the body of the request / uri response must return true (valid) or false (invalid) valid_path Boolean Y a true value will check localhost to determine if file path is valid example_values List of Strings or Numbers Y Y available a list of values which satisfy all the validation requirements field_title String n/a Y Y Y Y Y available the title of the component for documentation and error reporting field_description String n/a Y Y Y Y Y available a description of the component for documentation and error reporting field_position Integer n/a Y Y Y Y Y available the position of the component in an ordered array of fields field_metadata Map n/a Y Y Y Y Y available a dictionary for metadata about the component that passes through validation check","title":"List of Field Conditionals"},{"location":"reference/#error-handling","text":"Errors created from improper model specification will raise a ModelValidationError with a message that is designed to help determine the source of the model declaration error. To ensure that model initialization occurs properly, no error encoding is included to handle these exceptions. However, it is expected that validation of inputs will produce errors. Otherwise, what\u2019s the point?! So, in addition to a text report, a dictionary has been included with the InputValidationError exception to facilitate error handling. Error Method Example :: self.error = { 'model_schema': { 'datetime': 1456190345.543713, 'address': { 'country_code': 0, 'city': 'New Orleans', 'postal_code': '', 'region': 'LA', 'country': 'United States' }, 'comments': [ '@GerardMaras Rock the shrimp bouillabaisse!' ], 'active': True, 'rating': 8, 'reference': None, 'userID': 'gY3Cv81QwL0Fs', 'emoticon': 'aGFwcHk=', }, 'input_path': '.', 'input_criteria': { 'required_field': True, 'value_datatype': 'map', 'min_size': 10, 'max_size': 300, 'maximum_scope': [ 'datetime', 'address', 'active', 'userID', 'comments', 'rating', 'emoticon' ], 'extra_fields': False }, 'failed_test': 'extra_fields', 'error_value': 'extraKey', 'error_code': 4003 }","title":"Error Handling"},{"location":"reference/#order-of-exceptions","text":"The validation process will raise an error as soon as it encounters one, so there is no guarantee that the error that is reported is the only error in the input. Since there is no set order to the keys in a dictionary, there is also no guaranteed a priori order to the evaluation process. However below is an overview of the order of the steps of the validation process: Structure: Input is a dictionary Required keys in the input Extra keys in the input Value of each key in the input (recursive) (see below) Inject default values for missing optional keys Values (or Items): Datatype of value Other value qualifiers based upon datatype Identity, Lambda and URL qualifiers # TODO To help the process of error handling and client-server negotiation, both the schema for the model as well as the the map of conditional qualifiers for the field that raised the error are included in the error dictionary.","title":"Order of Exceptions"},{"location":"reference/#ingesting-kwargs","text":"The process of ingestion recursively walks the valid model searching for key-value pairs which match the keyword arguments of the input. For each match it finds, it constructs a key-value pair in the dictionary using the following rules (in order): Value in kwargs if field passes all its component validation tests Default value declared for the key in the model Empty value appropriate to datatype of key in the model Like the core validation method, ingestion will also walk through each item in a list field of the kwargs if the item type itself is also a list or dictionary. However, because invalid data will be replaced by empty values appropriate to the datatype declared in the model, unlike the core validation model, output data from ingest may not be model valid data. If it is desirable to ensure that the data is valid, a \u2018default_value\u2019 should be declared for each key in the components section of the data model and the \u2018min_size\u2019 of each list declaration should only be set to 0. Sample Kwargs :: { \"userID\": \"6nPbM9gTwLz3f\", \"datetime\": 1449179763.312077, \"active\": false, \"emoticon\": \"aGFwcHIk=\", \"comments\": [ \"gold\", \"silver\", \"bronze\", \"pewter\" ], \"address\": { \"region\": \"NY\", \"country\": \"United States\" } } Ingest Sample :: output = jsonModel.ingest(**sample_kwargs) Sample Output :: { 'userID': '6nPbM9gTwLz3f', 'datetime': 1449179763.312077, 'active': False, 'rating': 5, 'reference': None, 'emoticon': 'aGFwcHIk=' 'comments': ['gold', 'silver', 'bronze'], 'address': { 'postal_code': '', 'city': 'New York', 'country_code': 0, 'region': 'NY', 'country': 'United States' } } Ingest Empty :: output = jsonModel.ingest(**{}) Empty Output :: { 'userID': '', 'datetime': 0.0, 'active': False, 'rating': 5, 'reference': None, 'emoticon': '' 'comments': [], 'address': { 'postal_code': '', 'city': 'New York', 'country_code': 0, 'region': '', 'country': '' } }","title":"Ingesting Kwargs"},{"location":"reference/#extra-keywords","text":"If \u2018extra_fields\u2019 is declared True in the components for a dictionary in the model, then any extraneous keys in the corresponding dictionary in the kwargs will be added to the output.","title":"Extra Keywords"},{"location":"reference/#too-many-items","text":"Items are only added to a list from those items in kwargs if they are valid. If the number of valid items in a list in the kwargs exceeds the \u2018max_size\u2019 of the corresponding list in the model, then subsequent items are not added to the list once the list reaches its maximum size.","title":"Too Many Items"},{"location":"reference/#query-criteria","text":"Query criteria are composed of a dictionary of one or more key-value pairs, where the key names are the dot path to the fields in the model schema to be queried and the values are dictionaries containing any of the conditional operators for the query on the respective fields. Like component declarations, the \u201c.\u201d at the beginning of the dot path for a key name is optional. For fields with number, string or boolean datatypes, { \u201cfield\u201d: { \u201cequal_to\u201d: \u201cvalue\u201d } } can be shortened to { \u201cfield\u201d: \u201cvalue\u201d } and the class will automatically interpret the syntax as the \u201cequal_to\u201d criteria. Query criteria can be simple, such as the single field, operator and qualifier in the example in Home , or elaborate, such as found in the provided model sample-query.json below: Sample Query :: { \".active\": { \"value_exists\": true, \"equal_to\": false }, \".address\": { \"max_size\": 100 }, \".address.country\": \"United States\", \".address.city\": { \"discrete_values\": [ \"New Orleans\", \"New York\", \"Los Angeles\", \"Miami\"] }, \".address.country_code\": { \"discrete_values\": [36, 124, 554, 826, 840], \"integer_data\": true }, \".address.region\": { \"contains_either\": [\"[A-Z]{2}\", \"[A-Z][a-z]+\"], \"greater_than\": \"AB\", \"less_than\": \"Yyyyyyyyyyyyyyyyyyyyyyyy\" }, \".comments\": { \"max_size\": 3, \"min_size\": 1, \"unique_values\": true }, \".comments[0]\": { \"max_length\": 140, \"must_contain\": [\"[a-zA-Z]{2,}\"] }, \".datetime\": { \"greater_than\": 1.1, \"less_than\": 2000000000.0 }, \".emoticon\": { \"byte_data\": true, \"excluded_values\": [\"c2Fk\"] }, \".rating\": { \"excluded_values\": [7, 9], \"max_value\": 10, \"min_value\": 1 }, \".userID\": { \"max_length\": 13, \"max_value\": \"yyyyyyyyyyyyy\", \"min_length\": 13, \"min_value\": \"1111111111111\", \"must_not_contain\": [\"[^\\\\w]\", \"_\"] } } The query method follows a similar process by which input is validated. A record whose field values evaluate to true for all criteria returns true. Otherwise, something in the record does not match one or more query criteria and the query method returns false. Because the query method returns a false as soon as it encounters a failed criteria from a dictionary of fields in the query criteria, query time will vary based upon the number of records, how many fail and how many fields are added to the query criteria.","title":"Query Criteria"},{"location":"reference/#querying-items","text":"Although the query method will evaluate items nested inside lists to an arbitrary depth, it does so by evaluating all items in the list and all sub-branches of any nested lists inside the list. As a result, querying items inside lists suffers non-linear explosion. And, unlike the process of item ingestion, if any item in a list (or branch of a sub-list) evaluates to true to the criteria provided the entire list will evaluate to true. Be Warned","title":"Querying Items"},{"location":"reference/#query-errors","text":"If query criteria contain fields, operators or qualifiers which are outside the scope of the model, the query method will produce a QueryValidationError. To handle a QueryValidationError:: try: query_results = validModel.query(invalid_criteria, test_record) except QueryValidationError as err: assert isinstance(err.error['message'], str)","title":"Query Errors"},{"location":"reference/#query-rules-customization","text":"When the model is initialized, it accepts an optional dictionary for customized query rules. The primary purpose of this customization is to limit query criteria validation to only those query operations which are supported by a specific query engine. Optional query rules must be structured according to the components field of the model-rules.json file and cannot contain any fields, operators or qualifiers outside the full range of the model query rules. Query Rules :: { \".boolean_fields\": { \"identical_to\": \".similar_boolean\", \"lambda_function\": \"\", \"validation_url\": \"\", \"value_exists\": false, \"equal_to\": false }, \".list_fields\": { \"identical_to\": \".similar_list\", \"lambda_function\": \"\", \"max_size\": 0, \"min_size\": 0, \"unique_values\": false, \"validation_url\": \"\", \"value_exists\": false }, \".map_fields\": { \"identical_to\": \".similar_map\", \"lambda_function\": \"\", \"max_size\": 0, \"min_size\": 0, \"validation_url\": \"\", \"value_exists\": false }, \".null_fields\": { \"identical_to\": \".similar_null\", \"lambda_function\": \"\", \"validation_url\": \"\", \"value_exists\": false }, \".number_fields\": { \"discrete_values\": [], \"excluded_values\": [], \"greater_than\": 0.0, \"identical_to\": \".similar_number\", \"integer_data\": false, \"lambda_function\": \"\", \"less_than\": 0.0, \"max_value\": 0.0, \"min_value\": 0.0, \"validation_url\": \"\", \"value_exists\": false, \"equal_to\": 0.0 }, \".string_fields\": { \"byte_data\": false, \"contains_either\": [], \"discrete_values\": [], \"excluded_values\": [], \"greater_than\": \"\", \"identical_to\": \".similar_string\", \"lambda_function\": \"\", \"less_than\": \"\", \"max_length\": 0, \"max_value\": \"\", \"min_length\": 0, \"min_value\": \"\", \"must_contain\": [], \"must_not_contain\": [], \"validation_url\": \"\", \"value_exists\": false, \"equal_to\": \"\" } } [The lambda_function, identical_to and validation_url operators are not yet supported by the model.] A malformed query rules argument on model initialization will produce a ModelValidationError.","title":"Query Rules Customization"},{"location":"roadmap/","text":"Roadmap Features Validates native json datatypes Validates byte data as base64 encoded strings Alternative to json schema module Schema declaration is self-valid Built-in validation of model declaration Flat structure to object property attribute declarations Ability to assign default values to inputs Validates individual components in a model Ingests arbitrary keyword data and outputs model valid dictionary Validates query criteria against model scope Evaluates model valid records using query criteria Validates the byte size of a map field Provides colloquial explanations of errors Nothin\u2019 Yet (aka TODO) Change custom error argument to accept .format syntax Validates that a path exists on localhost Verifies that a url is responsive Custom validations with lambda functions Custom validations with web url Compares one field against another field","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#features","text":"Validates native json datatypes Validates byte data as base64 encoded strings Alternative to json schema module Schema declaration is self-valid Built-in validation of model declaration Flat structure to object property attribute declarations Ability to assign default values to inputs Validates individual components in a model Ingests arbitrary keyword data and outputs model valid dictionary Validates query criteria against model scope Evaluates model valid records using query criteria Validates the byte size of a map field Provides colloquial explanations of errors","title":"Features"},{"location":"roadmap/#nothin-yet-aka-todo","text":"Change custom error argument to accept .format syntax Validates that a path exists on localhost Verifies that a url is responsive Custom validations with lambda functions Custom validations with web url Compares one field against another field","title":"Nothin' Yet (aka TODO)"},{"location":"test/","text":"Field Datatype Required Default Examples Conditionals Description userID string yes \"gY3Cv81QwL0Fs\" min_length: 13 max_length: 13 min_value: \"1111111111111\" max_value: \"yyyyyyyyyyyyy\" must_not_contain: ['[^\\\\w]', '_'] 13 digit unique base 64 url safe key datetime number yes 1456190345.543713 greater_than: 1.1 less_than: 2000000000.0 https://collectiveacuity.com active boolean yes true equal_to: false emoticon string yes \"aGFwcHk=\" byte_data: true excluded_values: ['c2Fk'] reference null null rating number 5 8 integer_data: true max_value: 10 min_value: 1 excluded_values: [7, 9] address object yes {...} city string \"New York\" \"New Orleans\" discrete_values: ['New Orleans', 'New York', 'Los Angeles', 'Miami'] region string yes \"LA\" greater_than: \"AB\" less_than: \"Yyyyyyyyyyyyyyyyyyyyyyyy\" contains_either: ['[A-Z]{2}', '[A-Z][a-z]+'] State or Province postal_code string \"\" country string yes \"United States\" country_code number 0 integer_data: true discrete_values: [36, 124, 554, 826, 840] comments array of strings [...] min_size: 1 max_size: 3 unique_values: true item string \"couldn't find the place\", \"hidden gem!!!!\" max_length: 140 must_contain: ['[a-zA-Z]{2,}'] **extra fields allowed","title":"Test"}]}